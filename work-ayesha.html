<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms in City Design</title>
    <style>
        body {
            background-color: black;
            color: pink;
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 20px;
        }

        button {
            background-color: pink;
            color: black;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
            border-radius: 5px;
        }

        button:hover {
            background-color: #ff66b2;
        }

        .code-container {
            display: none;
            margin-top: 20px;
            text-align: left;
            background-color: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
        }

        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #00ff00;
        }
    </style>
</head>
<body>
    <h1>Algorithms in City Design</h1>
    <p>Click on the buttons below to view the respective algorithm code.</p>

    <button onclick="showCode('kmp')">Dijkstra's Algorithm - Shortest Path </button>
    <button onclick="showCode('bst')">Prim's Algorithm - Parking Lot Connection</button>
    <button onclick="showCode('fenwick')">Quick Sort - Exam Hall Allocation</button>

    <div id="dijkstra's" class="code-container">
        <h2>Dijkstra's Algorithm - Shortest Path</h2>
        <pre>
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm> 
#include <string>

using namespace std;

string toLowerCase(const string& str) {
    string result = str;
    transform(result.begin(), result.end(), result.begin(), ::tolower);
    return result;
}

void dijkstra(int source, vector<vector<pair<int, int>>>& graph, vector<int>& distances, vector<int>& predecessors) {
    int n = graph.size();
    distances.assign(n, INT_MAX);        // Initialize distances with infinity
    predecessors.assign(n, -1);         // Initialize predecessors with -1
    distances[source] = 0;

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // Min-heap
    pq.push({0, source}); // Push the source with distance 0

    while (!pq.empty()) {
        int currentDistance = pq.top().first;
        int currentNode = pq.top().second;
        pq.pop();

        if (currentDistance > distances[currentNode]) continue;

        for (auto& neighbor : graph[currentNode]) {
            int nextNode = neighbor.first;
            int weight = neighbor.second;

            if (distances[currentNode] + weight < distances[nextNode]) {
                distances[nextNode] = distances[currentNode] + weight;
                predecessors[nextNode] = currentNode; // Update the predecessor
                pq.push({distances[nextNode], nextNode});
            }
        }
    }
}

vector<int> reconstruct_path(int source, int target, const vector<int>& predecessors) {
    vector<int> path;
    for (int at = target; at != -1; at = predecessors[at]) {
        path.push_back(at);
    }
    reverse(path.begin(), path.end()); 
    if (path.front() == source) return path;
    return {}; 
}

int main() {
    // Fixed nodes and locations
    unordered_map<string, int> nameToIndex = {
        {"universitymaingate", 0}, {"cs", 1}, {"ec", 2}, {"mechanical", 3}, {"biotech", 4},
        {"eee", 5}, {"library", 6}, {"parking", 7}, {"residentialarea", 8}, {"gym", 9},
        {"park", 10}, {"adminblock", 11}, {"railwaystation", 12}, {"hostel", 13},
        {"busstand", 14}, {"mall", 15}, {"school", 16}, {"restaurant", 17},
        {"ithub", 18}, {"hospital", 19}, {"medicalcollege", 20}
    };

    unordered_map<int, string> indexToName = {
        {0, "UniversityMainGate"}, {1, "CS"}, {2, "EC"}, {3, "Mechanical"}, {4, "Biotech"},
        {5, "EEE"}, {6, "Library"}, {7, "Parking"}, {8, "ResidentialArea"}, {9, "Gym"},
        {10, "Park"}, {11, "AdminBlock"}, {12, "RailwayStation"}, {13, "Hostel"},
        {14, "BusStand"}, {15, "Mall"}, {16, "School"}, {17, "Restaurant"},
        {18, "ITHub"}, {19, "Hospital"}, {20, "MedicalCollege"}
    };

    vector<vector<pair<int, int>>> graph(21); // Graph with 21 nodes

    // Manually defining connections (edges) and distances
    vector<tuple<string, string, int>> edges = {
        {"universitymaingate", "cs", 2}, {"universitymaingate", "ec", 3},
        {"universitymaingate", "biotech", 4}, {"universitymaingate", "mechanical", 4},
        {"universitymaingate", "eee", 3}, {"universitymaingate", "parking", 5},
        {"cs", "ec", 4}, {"cs", "library", 6}, {"ec", "mechanical", 3},
        {"mechanical", "biotech", 5}, {"biotech", "eee", 7}, {"eee", "library", 2},
        {"library", "parking", 3}, {"parking", "residentialarea", 5},
        {"residentialarea", "gym", 6}, {"gym", "park", 2}, {"park", "adminblock", 8},
        {"adminblock", "railwaystation", 4}, {"railwaystation", "hostel", 10},
        {"hostel", "busstand", 7}, {"busstand", "mall", 3}, {"mall", "school", 6},
        {"school", "restaurant", 4}, {"restaurant", "ithub", 5},
        {"ithub", "hospital", 8}, {"hospital", "medicalcollege", 2}
    };

    // Add edges to the graph
    for (auto& edge : edges) {
        string from, to;
        int weight;
        tie(from, to, weight) = edge;
        int u = nameToIndex[from];
        int v = nameToIndex[to];
        graph[u].push_back({v, weight});
        graph[v].push_back({u, weight}); // Assuming undirected graph
    }

    // Display available nodes and connections
    cout << "Available locations:" << endl;
    for (const auto& pair : nameToIndex) {
        cout << pair.first << endl;
    }

    cout << "\nConnections (edges):" << endl;
    for (const auto& edge : edges) {
        string from, to;
        int weight;
        tie(from, to, weight) = edge;
        cout << from << " --(" << weight << ")--> " << to << endl;
    }

    string targetName;
    cout << "\nEnter the target location: ";
    cin >> targetName;

    // Convert the input to lowercase for case-insensitive comparison
    targetName = toLowerCase(targetName);

    // Try to find the index in the map
    auto targetIt = nameToIndex.find(targetName);

    if (targetIt == nameToIndex.end()) {
        cout << "Invalid target location!" << endl;
        return 0;
    }

    int source = 0; 
    int target = targetIt->second;

    vector<int> distances, predecessors;
    dijkstra(source, graph, distances, predecessors);

    if (distances[target] == INT_MAX) {
        cout << "No path exists to " << targetName << endl;
    } else {
        cout << "Shortest distance from UniversityMainGate to " << targetName << ": " << distances[target] << endl;

        vector<int> path = reconstruct_path(source, target, predecessors);
        cout << "Shortest path: ";
        for (int node : path) {
            cout << indexToName[node] << " ";
        }
        cout << endl;
    }

    return 0;
}        </pre>
    </div>

    <div id="prim's" class="code-container">
        <h2>Prim's Algorithm - Parking Lot Connection</h2>
        <pre>
#include <iostream>
#include <vector>
#include <climits>
#include <queue>
#include <map>
#include <algorithm>  // <-- Add this line

using namespace std;

// Structure for edges in the graph
struct Edge {
    int to, weight;
};

// Function to implement Prim's algorithm
void primsAlgorithm(int n, vector<vector<Edge>>& graph, int startNode) {
    vector<int> minCost(n, INT_MAX);   // Stores minimum cost to connect each node
    vector<bool> inMST(n, false);       // Tracks nodes included in MST
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // Min-heap (priority queue)

    minCost[startNode] = 0;
    pq.push({0, startNode});

    int totalCost = 0;

    while (!pq.empty()) {
        int node = pq.top().second;
        int cost = pq.top().first;
        pq.pop();

        // If node is already in MST, skip it
        if (inMST[node]) continue;

        // Add node to MST and update the total cost
        inMST[node] = true;
        totalCost += cost;

        // Traverse all neighbors of the current node
        for (const auto& edge : graph[node]) {
            int nextNode = edge.to;
            int edgeWeight = edge.weight;

            // If the edge is not in MST and is better (cheaper), add it to the queue
            if (!inMST[nextNode] && edgeWeight < minCost[nextNode]) {
                minCost[nextNode] = edgeWeight;
                pq.push({edgeWeight, nextNode});
            }
        }
    }

    cout << "Total minimum cost to connect all parking lots: " << totalCost << " meters" << endl;
}

int main() {
    int n, m;

    // Input number of parking lots (nodes)
    cout << "Enter number of parking lots (nodes): ";
    cin >> n;

    // Create graph representation (adjacency list)
    vector<vector<Edge>> graph(n);

    // Create a map for parking lot names
    map<int, string> parkingLotNames;

    // Input parking lot names
    cout << "Enter the names of parking lots: " << endl;
    for (int i = 0; i < n; ++i) {
        cout << "Enter name for parking lot " << i << ": ";
        cin >> parkingLotNames[i];
    }

    // Input number of connections (edges)
    cout << "Enter the number of connections (roads): ";
    cin >> m;

    // Input the connections
    cout << "Enter the connections in the format: <From parking lot name> <To parking lot name> <Distance>" << endl;
    for (int i = 0; i < m; ++i) {
        string fromName, toName;
        int from, to, distance;

        cout << "Connection " << i + 1 << ": ";
        cin >> fromName >> toName >> distance;

        // Find the indices corresponding to the names
        from = find_if(parkingLotNames.begin(), parkingLotNames.end(), [&](const pair<int, string>& p) { return p.second == fromName; })->first;
        to = find_if(parkingLotNames.begin(), parkingLotNames.end(), [&](const pair<int, string>& p) { return p.second == toName; })->first;

        graph[from].push_back({to, distance});
        graph[to].push_back({from, distance}); // Since the graph is undirected
    }

    // Input the starting parking lot name
    string startName;
    cout << "Enter the starting parking lot name: ";
    cin >> startName;

    // Find the index of the starting parking lot
    int startNode = find_if(parkingLotNames.begin(), parkingLotNames.end(), [&](const pair<int, string>& p) { return p.second == startName; })->first;

    // Run Prim's algorithm to find the minimum spanning tree
    primsAlgorithm(n, graph, startNode);

    return 0;
}
        </pre>
    </div>

    <div id="quick sort" class="code-container">
        <h2>Quick Sort - Exam Hall Allocation</h2>
        <pre>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

// Function to implement Quick Sort
void quickSort(vector<int>& usns, int low, int high) {
    if (low < high) {
        int pivot = usns[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (usns[j] <= pivot) {
                i++;
                swap(usns[i], usns[j]);
            }
        }
        swap(usns[i + 1], usns[high]);

        int pi = i + 1;

        // Recursively sort the two halves
        quickSort(usns, low, pi - 1);
        quickSort(usns, pi + 1, high);
    }
}

// Function to allocate students to exam halls based on bench capacity
void allocateHalls(vector<int>& usns, vector<string>& halls, vector<int>& benches) {
    int numStudents = usns.size();
    int numHalls = halls.size();

    int studentIndex = 0;
    for (int i = 0; i < numHalls; ++i) {
        int benchesInHall = benches[i];
        cout << "Allocating students to " << halls[i] << " (Capacity: " << benchesInHall << "):" << endl;

        // Allocate students to the current hall based on bench capacity
        for (int j = 0; j < benchesInHall && studentIndex < numStudents; ++j, ++studentIndex) {
            cout << "USN: " << usns[studentIndex] << " is allocated to " << halls[i] << endl;
        }

        // If there are still students left after filling this hall
        if (studentIndex >= numStudents) {
            break; // No more students to allocate
        }
    }

    // If there are more students than the total capacity of all halls
    if (studentIndex < numStudents) {
        cout << "\nSome students couldn't be allocated due to insufficient capacity in all halls!" << endl;
    }
}

int main() {
    int numStudents, numHalls;

    // Input number of students
    cout << "Enter the number of students: ";
    cin >> numStudents;

    // Generate the USNs automatically from 1 to numStudents
    vector<int> usns(numStudents);
    for (int i = 0; i < numStudents; ++i) {
        usns[i] = i + 1;  // USNs are sequential starting from 1
    }

    // Input number of exam halls
    cout << "Enter the number of exam halls: ";
    cin >> numHalls;

    vector<string> halls(numHalls);
    vector<int> benches(numHalls);

    // Input the names of the exam halls and the number of benches in each hall
    cout << "Enter the names of exam halls and the number of benches in each hall:" << endl;
    for (int i = 0; i < numHalls; ++i) {
        cout << "Hall " << i + 1 << " name: ";
        cin >> halls[i];
        cout << "Hall " << i + 1 << " number of benches: ";
        cin >> benches[i];
    }

    // Step 1: Sort USNs using Quick Sort (or any other sorting method)
    quickSort(usns, 0, numStudents - 1);

    // Step 2: Allocate exam halls to students based on bench capacity
    allocateHalls(usns, halls, benches);

    return 0;
}
        </pre>
    </div>

    <script>
        function showCode(id) {
            document.querySelectorAll('.code-container').forEach(container => {
                container.style.display = 'none';
            });
            document.getElementById(id).style.display = 'block';
        }
    </script>
</body>
</html>
